### mysql优化原理

#### 存储引擎

innodb存储引擎：支持行锁，支持事务，索引类型分BTRR+，HASH，mysql默认存储引擎。

myISAM存储引擎：支持表锁，不支持事务，支持索引为全文索引类型。

#### 索引定义

索引是存储引擎问了便于快速查找记录的一种数据结构。

#### 索引的类型

索引是在存储引擎层实现的，所以不同的存储引擎可能索引的实现原理是不一样的。所以我这里讲解的是mysql中存储引擎为InnoDB的索引。

##### B+Tree索引

###### 索引优点

* 索引大大减小了服务器扫描的数据量
* 索引可帮助服务避免排序和临时表
* 索引可以将随机I/O变成顺序I/O

###### 特点

* 索引中的树是有序的，查找方便
* 可以用于查询order by 操作

###### 限制

* 如果不是按照最左索引列开始查找，则索引无效。

* 不能跳过索引中的列

* 如果查询中有某个范围列的查询，则其右边所有列都无法使用索引优化查询。例如：

  ~~~sql
  select * from tb_agent_user u where u.agent_id = '12' and u.user_id like 'wang%' and u.login_name ='p2p_wang';
  ~~~

这里假如我的索引是key(agent_id,user_id,login_name)，这里，user_id使用了模糊查询，所以只能使用agent_id,user_id的作为索引。

##### Hash索引

hash索引是基于hash表实现。对于每一行数据，存储引起都会计算一个hash值，哈希索引将所有的hash值存储在索引中，同时在hash表中保存指向每个数据行的指针。查询只需要一次即可。

* 优点

hash索引只保存对应的hash值，而hash值本身很小，所以避免了存储空间的浪费，这也让查找起来非常快。

* 缺点

其实hash索引在查找起来也是有局限性的，因为每一行都是经过hash算法计算之后的hash值保存在索引中，所以并不能保证hash值得顺序就代表了数据行的顺序，所以在group by的时候，并不能只用hash索引。

hash索引在查找的时候，必须是根据建立索引列的hash算法来查找，所以并不支持部分索引列查找。，比如 key using hash(A,B)，由于hash(A)，与hash(A,B)的值并不想等，所以如果是用索引A的查询，是无效的。

如果hash索引冲突很多的话，一些索引维护操作的代价也会很高。如果在重复性数据比较多的列上建立了hash索引，那么在删除的时候，存储引起需要遍历hash()值对应地址下所有链表中的每一行，找到并删除对应行的引用。

#### 高性能的索引策略

正确创建和使用索引能大大加快查询速度，所以如何创建索引就成了关键。

###### 独立的列

独立的列是指索引不能是表达式的一部分，也不能是函数的参数。

~~~sql
selece * from tb_agent g where g.agent_no + 1 = P0014;
~~~

因为我们的索引是已经排好序的，如果直接使用索引便可以立即找到，但是这了对索引做了运算，mysql无法对这个表达式进行运算，没有办法把g.agent_no + 1当做一个索引来看。所以如果索引建立在g.agent_no 上，此时是不起任何作用的。

###### 前缀索引和索引选择性

索引的选择性 = 不重复的索引值/数据表的记录数(T)。范围从1/T~1之间。索引的选择性越高，则查询效率越高。所以，如果有些字段长度太长，建立索引的话，就浪费了索引空间，这个时候，我们可以根据索引的选择性来判断，是不是取这个字段的前面的一些值能够满足索引的选择性为1，也就是唯一索引的功能。

###### 多列索引

根据我们前面对索引操作的介绍，我们知道，建立索引是需要空间的，而且插入，删除，修改一条记录，也是需要维护索引的，所以索引并不是建立的越多越好。

~~~sql
select * from tb_agent_user u where u.user_id = '1' and u.agent_id = '2'
~~~

这里，并不是说建立user_id为索引，并且建立agent_id为索引好，这里可以全局看一下，是不是还有别的查询条件用到了这两个索引之一，比如说，还有一个表用到了u.user_id为where条件，那么此时，我们建立索引的是好应该是多列索引，而且已最左原则为标准：建立的索引应该是index(user_id,agent_id)。

###### 选择合适的索引列顺序

我们建立索引列最大的难题就是如何选择索引列的顺序，而且也满足order by,group by，distinct的需求。当不用考虑排序和分组的时候，我们通常将选择性最高的列放到索引的最左边。但是，这也是在考虑到多个查询的时候，选择合适的索引顺序为准。

###### 覆盖索引

覆盖索引：如果一个索引包含（或者说是覆盖）索要查询的字段的值，我们就称之为覆盖索引。也就是说我们查找数据只需要查找索引就可以获取到要的数据，而不需要回表查询了。

~~~sql
select g.user_id,g.agent_id from tb_agent_user g;
~~~

假如我们在tb_agent_user表中建立覆盖索引index(user_id,agenata_id)，那么此时我们查找这两列数据的时候，就直接查找索引就可以获取，而不需要回表查询。

#### 查询优化

###### where条件查询

一般mysql能够使用三种方式执行where条件，从好到坏依次为：

* 在索引中使用where条件查询，这个发生在存储引擎层。
* 使用覆盖索引直接在索引中获取值，不需要回表查询。在mysql服务层完成的。
* 从数据表中返回数据，然后where筛选，这个在服务层完成。

###### 复杂查询还是简单查询

由于mysql从设计上让链接和断开链接都很轻量级，在返回一个小的查询结果方面很高效。所以建议是根据需求来定简单查询还是负责查询，如果说一个复杂查询能够做到的事情，但是需要你做10次简单的查询，这个时候就没有必要拆分为多个简单查询了。

#### mysql执行查询原理

1. 客户端向mysql服务器发出一条查询sql。
2. mysql服务端先检查缓存（前提是缓存设置开着），如果命中缓存，直接返回给客户端，如果没有命中，继续执行。
3. 服务器进行sql解析，预处理，再由优化器生成执行计划。
4. mysql根据优化器生成的执行计划，调用存储引擎的api执行查询（数据真正存储的地方是存储引擎）。
5. 返回结果给客户端。

###### mysql客户端/服务器通信协议

客户端和服务器端通信是半双工的，也就是说要么是客户端给服务器发送请求，要么是服务器端给客户端发送请求，两者是不能同时发生的。

###### 查询缓存

在解析一个查询sql之前，如果查询缓存是打开的，那么mysql会优先检查是否命中查询缓存。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果。当然，如果在检查到命中缓存，在返回数据之前是会先验证是否有这个操作权限的。

###### 查询优化处理

查询优化是将sql转化为一个执行计划，mysql依照这个执行计划去存储引擎取数据。这以环节主要包括：语法解析，查询优化，生成执行计划。

* **语法解析和预处理**

  mysql主要通过关键字对sql进行语法解析，并生成一颗解析树。mysql解析器使用语法验证规则和解析查询，验证sql是否有语法错误，使用关键字顺序是否正确等。预处理器则根据一些mysql规则进行进一步检查解析书是否合法，比如，数据表是否存在，解析名字和别名是否有歧义等。

* **查询优化器**

  现在解析树是合法的，到了这里需要进行查询优化。mysql的查询是基于成本的优化器，将尝试预测一个查询使用某种计划时的成本，选择一个最小成本。但是查询优化也并不是100%的准确，下面几个因素会影响优化器的选择：

  1. 统计信息不准确。mysql依赖存储引擎的统计信息来预测成本。但是存储引擎并不一定能提供准确的统计信息，比如InnoDB因为其MVCC的架构，并不能维护一个数据表的行数的精确信息。
  2. 执行技术中的估算成本并不一定与实际的成本一致。

  下面是mysql查询优化器能够执行的优化类型：

  1. 重新定义关联表的顺序

     数据表的关联顺序并不总是按照sql指定的查询顺序出现。

  2. 将外链接转化为内连接

     并不是所有的OUTER JOIN 语句都必须以外链接的方式执行，例如：where条件，库表结构都可能会让外链接等价于一个内连接。

  3. 使用等价变化

     比如 a>5 and a=5 会变成：a>= 5

  4. 优化COUNT(),MIN(),MAX()

  5. 预估并转化为常数表达式

     ~~~sql
     select f.file.id,a.actor_id from tb_film f INNER JOIN tb_file_actor a USING(file_id) where a.file_id = 1;
     ~~~

     mysql分为两步执行这个查询第一步：从tb_file中查到需要的行，由于有film_id上面有索引，所以mysql知道返回一行数据，优化器在生成执行计划的时候，就明确知道有多少个值了，此时这里的表访问类型就是const.第二步，将第一步返回的film_id当做一个已知值来处理，所以访问类型还是const。也就是说执行计划里，这两张表的访问类型都是const。

  6. 列表IN()查询

     在mysql中对于IN()查询的原理是先对IN中的值进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个O(log n)复杂度的操作。

* mysql执行关联查询

  1. 对于UNNION查询的处理

     mysql对于unnion查询的处理，第一步是：将一些列的单个查询结果放到一张临时表中，第二步：再重新读出临时表数据来完成union查询。

     当前mysql执行关联操作的策略很简单：**mysql对任何关联都执行嵌套循环关联操作，就是说mysql现在一个表中循环去除单条数据，然后再嵌套循环到下一个表中寻找匹配的行，一次下去，知道找到所有表中的匹配数据为止。然后再根据匹配的数据返回查询中要的各个列**。

     ~~~sql
     select * from tb_agent_user u inner join tb_agent g on g.id = u.agent_id where u.user_id = '123';
     ~~~

     我们来分析一下这个是怎么执行的，假如u中有三条数据分别是A,B,C

     首先查tb_agent_user 中查到A，然后到tb_agent 表中查到满足条件的两条记录：A1，A2.

     然后查tb_agent_user 中查到B，然后到tb_agent表中查到满足条件的三条记录为：B1，B2，B3

     然后查tb_agent_user中查到C，然后到tb_agent表中查到满足条件的两条记录：C1，C2.

     那么返回的记录数为：A1，A2，B1，B2，B3，C1，C2。

     ~~~java
     List A = select * from tb_agent_user u where u.user_id = '123';
     List result ;
     while(A.hasNext()){
     	List B = select * from tb_agent g where g.id = A.next().agent_id;
       	if(B.isEmpty()){
           continue;
       	}
       result.addAll(merge(A,B));//merge(A,B)是A,B的交集
     }

     ~~~

     返回的结果就是result。

     针对于left join而言：

     ~~~java
     select * from tb_agent_user u left join tb_agent g on g.id = u.agent_id where u.user_id = '123';
     ~~~

     我们来分析一下，怎么执行的。

     ~~~java
     List A = select * from tb_agent_user u where u.user_id = '123';
     List result ;
     while(A.hasNext()){
     	List B = select * from tb_agent g where g.id = A.next().agent_id;
         result.addAll(leftMerge(A,B));//不管B有没有查到与A关联的数据，都以左表A的数据为准返回。
     }
     ~~~

     当我们的是left join连接的时候，都是以左表数据为准，如果右表数据没有查到与A相关的数据，那么返回的时候，全部返回A的数据，且B表数据展示全部为null。同理，如果是rigth join链接的时候，就是以右表数据为准，全部返回右表数据B，如果A表没有查到相关数据,则A表数据展示全部为null.

     **本质上说，mysql对所有类型的查询都以同样的方式运行。比如说，mysql在from中遇到子查询，就是先把子查询的数据查询放到临时表中，然后将这个临时表当做普通表处理，但是需要注意的是，这个临时表是没有索引的，所以在复杂查询的时候还是需要慎重使用。**

     2. 关联查询优化器

        这个关联查询优化器最主要的功能就是决定查多表关联查询的顺序。

        ~~~sql
        select * from tb_agent g 
        inner join tb_agent_user u on u.agent_id = g.id
        inner join tb_agent_area a on g.id = a.agent_id;
        ~~~

        我们可以看到上面有两个inner join连接，那是不是说明我们的mysql一定按照上面的顺序来执行呢?实际不是这样的，mysql会通过评估不同顺序查询的成本中选择一个最低成本的关联顺序来生成执行计划。比如，这个就是先扫描tb_agent_area ,然后再扫描tb_agent ,最后扫描tb_agent_user.

     3. 排序优化

        针对于排序，如果排序的字段没有索引的情况下，mysql需要自己排序。如果需要排序的数据多余排序缓冲区，那么久需要磁盘空间排序，mysql将数据分块，对每个独立的数据块使用“快速排序”，并将各个块的结果放到磁盘上，然后将各个排序好的块进行合并，最后返回结果。如果需要排序的数据比排序缓冲区小，那么直接在内存中进行快速排序。mysql将这个排序过程同意成为**文件排序(file sort)**.

        在关联查询的时候需要排序的话，mysql分两种情况处理：

        1. 第一种，order by子句中的所有列来自关联的第一张表，那么mysql在关联处理第一个表的时候就进行文件排序。这个时候，你用explain在查看执行计划的时候，extra字段显示的是：Using filesort.
        2. 第二种，order by 子句中的列不在第一个表中。mysql会将关联的结果放在一个临时表中，然后再所有的关联都结束后，进行文件排序。这个时候，Extra字段显示的是：Using temporary;Using filesort.

        ​

     ​

     ​


 


